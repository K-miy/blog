---
title: "argparse: un outil méconnu"
author: "Stéphane Caron"
date: '2019-05-21'
slug: optparse-package
categories: ["R"]
type: post
description: "Utiliser le package argparse pour faciliter l'appel de scripts R."
output: html_document
featured: "argparse-package.png"
featuredpath: "img/headers/"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

Dans les derniers mois, j'ai été confronté à 2 défis qui m'ont éventuellement permis de découvrir un package R et une manière de programmer qui m'étaient auparavant inconnus. Dans un premier temps, je devais intégrer l'appel de programmes R à l'intérieur d'un *shell script* (un fichier avec l'extension `.sh`) dans lequel je devais passer différents arguments ou paramètres qui allaient être utilisés par le programme. Dans un deuxième temps, je devais lancer un programme R avec différents paramètres à l'intérieur d'une instance *Amazon Web Services (AWS)*, pour laquelle je n'avais pas d'interface graphique. Dans les deux cas, je devais faire l'appel d'un programme R à partir de la ligne de commande, ce que j'ai compris qui était possible avec la commande `Rscript`, mais pour lequel je devais également passer des arguments à ce programme lors de l'appel. C'est à ce moment que j'ai fais la découverte du package [argparse](https://cran.r-project.org/web/packages/argparse/index.html), un outil méconnu par plusieurs et qui offre des fonctionnalités intéressantes.

# `argparse` et la ligne de commande

Comme vous l'avez probablement deviné dans l'introduction, `argparse` est un package R qui permet de facilter l'appel de programmes R à partir de la ligne de commande. Pour être plus précis, `argparse` est un package qui permet de créer une interface de ligne de commande (ou *command line interface* ou *CLI*). Cette interface agit en quelque sorte de pont (ou moyen de communication) entre l'appel d'une commande via le terminal et les opérations effectuées à l'intérieur d'un programme.

Pourquoi appeler un programme R de la ligne de commande alors qu'on peut le lancer directement de la majorité des *IDE* comme RStudio ou même à partir de R directement? Il y a plusieurs exemples qui pourraient être cités, les deux exemples mentionnés en introduction sont pour moi des applications courantes, surtout lorsqu'on doit utiliser des ressources en ligne comme des instances *AWS* pour plus de puissance de calculs. Ces instances sont souvent dépourvues d'interface graphique, ce qui fait en sorte que nous nous retrouvons souvent devant le terrifant écran noir du terminal.

# Fonctionnement

Le package R `argparse` est très similaire à la librarie Python du même nom. De plus, il existe d'autres packages R, comme [optparse](https://cran.r-project.org/web/packages/optparse/index.html), qui fonctionnent de manière similaire. L'objectif de cet article n'est pas de vanter un package plus d'un autre, mais plutôt d'illustrer le concept général en utilisant comme exemple le package `argparse`. La création d'une interface de ligne de commande avec ce package est très simple, les étapes sont généralement:

1. Définir les arguments pouvant être appelés de la ligne de commande
2. Parser les arguments et les stockés dans un objet (habituellement une liste)
3. Utiliser les éléments ce cette liste dans le programme

Les étapes 2 et 3 sont sont assez simples à réaliser. L'étape la plus cruciale est de bien définir les arguments (étape 1). Pour se faire, il y a quelques considérations à prendre en compte. Les prochaines sections vont permettre de mieux définir ces considérations.

## Initialiser l'objet `Parser`

Tout d'abord, avant même de définir les arguments, il faut attacher le package `argparse` et initialiser l'objet de type `Parser`. Nous pourrons ensuite ajouter des arguments à cet objets dans les prochaines sections.

```{r}
library(argparse)
parser <- ArgumentParser(description = "Simuler des distributions normales")
```

## Nommer les arguments

Maintenant que l'objet `Parser` est définit, il faut définir et nommer les arguments qui pourront être appelés à la ligne de commande. Pour ajouter ces arguments à notre objet, on utilise la méthode `add_argument()`. Il existe deux sortes d'arguments: les argument positionnels et les arguments optionnels. Dans le premier cas, ces arguments sont obligatoires et doivent être appelés dans un ordre précis alors que dans le deuxième cas, ils sont facultatifs et peuvent être appelés dans n'importe quel ordre, tant qu'ils sont nommés dans l'appel. Voici un exemple simple d'ajout de ces 2 sortes d'arguments:

```{r}
parser$add_argument("n_dist", type = "integer")
parser$add_argument("-m", "--mean", type = "double", default = 0)
```

Les arguments optionnels sont identifiés par le préfixe `-` alors que les autres seront considérés comme positionnels. Il est possible de spécifier le type de valeur de l'argument grâce à l'option `type` qui peut prendre les types suivants:

- "double"
- "character"
- "logical"
- "integer"

Les arguments optionnels doivent être accompagnés par une valeur par défaut. Notez que les arguments optionnels sont parfois nommés de 2 manières, avec un seul trait d'union (`-m`) pour l'abréviation courte et deux (`--mean`) pour le nom complet. Il n'est pas obligatoire de mettre les deux, mais cela peut améliorer la clarté de l'appel.

## Définir l'aide

Une fonctionnalité intéressante avec les interfaces de ligne de commande comme celle du package `argparse` est que l'on peut généralement définir une aide pour l'appel pour chaque argument pouvant être appelé par le programme. Cette aide peut être affichée en appelant l'argument `-h` ou `--help` au programme. Par exemple, 

```{r}
parser <- ArgumentParser(description = "Simuler des distributions normales")
parser$add_argument("n_dist", type = "integer",
                    help = "Nombre de distributions simulées")
parser$add_argument("-m", "--mean", type = "double", default = 0,
                    help = "Moyenne pour chaque distribution normale [défault: %(default)s]")
parser$print_help()
```

Notez que la valeur par défaut peut être incorporée dans l'aide.

## Fonctionnalités supplémentaires

- Groupe d'arguments
- Sub parser

## Une fois les arguments définits

Une fois les arguments bien définit, il ne reste plus qu'à *parser* les arguments passé à ligne de commande et les utiliser dans le programme en utilisant la fonction `parse_args()`:

```{r, eval=FALSE}
args <- parser$parse_args()
```

# Exemple

Voici un exmple de programme où est-ce qu'on veut simuler un certains nombre de lois normales et estimer les moyennes et écart-types de ces simulations. De plus, nous voulons avoir la possibilité de définir les paramètres de ces lois normales et aussi l'option de sauvergarder un graphique illustrant la densité estimé comparativement à la vraie densité.

```{r, eval=FALSE}
library(argparse)
library(ggplot2)


# Build Command Line Interface --------------------------------------------

parser <- ArgumentParser(description = "Simulate random normal distributions")
parser$add_argument("n_dist", type = "integer",
                    help = "Number of distributions to simulated")
parser$add_argument("-m", "--mean", type = "double", default = 0, metavar = "",
                    help = "mean for the simulated normal dist [default: %(default)s]")
parser$add_argument("-s", "--sd", type = "double", default = 1, metavar = "",
                    help = "sd for the simulated normal dist [default: %(default)s]")
parser$add_argument("-n", "--n-obs", type = "integer", default = 1000, metavar = "",
                    help = "number of simulations in each dist [default: %(default)s]")
parser$add_argument("-r", "--random-seed", type = "integer", default = 42, metavar = "",
                    help = "random seed selected [default: %(default)s]")
parser$add_argument("-g", "--graph-save", action = "store_true", 
                    help = "save the graph: [default: %(default)s]")
parser$add_argument("-p", "--path-graph", type = "character", default = "./graph.png", metavar = "",
                    help = "path to save graph [default: \"%(default)s\"]")

args <- parser$parse_args()

# Simulate normal distributions -------------------------------------------

set.seed(args$random_seed)

simulated_list <- lapply(1:args$n_dist, function(x) sort(rnorm(n = args$n_obs, mean = args$mean, sd = args$sd)))
simulated_matrix <- matrix(unlist(simulated_list), nrow = args$n_dist, ncol = args$n_obs, byrow = TRUE)
mean_distribution <- colMeans(simulated_matrix)

# Output mean and sd simulated
mean(mean_distribution)
sd(mean_distribution)

# Plot the simulated distributed
plot <- ggplot(data.frame(obs = mean_distribution), aes(obs)) +
  geom_histogram(aes(y = ..density.., color = "Simulated"), 
                 bins = 30) +
  stat_function(fun=function(x)dnorm(x, mean = args$mean, sd = args$sd),
                size = 2, aes(color = "True")) + 
  scale_y_continuous("Density") +
  scale_x_continuous("x") +
  scale_colour_manual("Distribution", values = c("gray", "red")) + 
  theme_classic()

# Save the graph
if (args$graph_save) {
  ggsave(args$path_graph, plot) 
}
```

# Conclusion

- doc Python
- autre libraries R
- j'espere vous aider
